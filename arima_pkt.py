# -*- coding: utf-8 -*-
"""arima_pkt.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/alam2018/ml_prediction_m1/blob/master/arima_pkt.ipynb
"""

#from google.colab import drive
#drive.mount('/content/drive')

#Define the slice to retrive the traffic simulation file
web_traffic = False
m2m = True
m2m_model1 = True

# Part 1 - Data Preprocessing

# Importing the libraries
import numpy as np
import matplotlib.pyplot as plt
#from google.colab import files
import pandas as pd

# Importing the training set
if web_traffic == True:
    eMBB = True
    if eMBB == True:
        dataset_train = pd.read_csv('/home/mdaa/traffic_prediction/web_traffic/train/traffic_simulation.csv', sep=';')
    else:
        dataset_train = pd.read_csv('/content/drive/My Drive/Colab Notebooks/traffic_prediction/data_URLLC/traffic_simulation.csv', sep=';')
        
if m2m == True:
    if m2m_model1 == True:
        dataset_train = pd.read_csv('/home/mdaa/traffic_prediction/m2m_traffic/model_1/traffic_simulation.csv', sep=';')
    else:
        dataset_train = pd.read_csv('/home/mdaa/traffic_prediction/m2m_traffic/model_2/traffic_simulation.csv', sep=';')
    

training_set = dataset_train.iloc[:, 1:2].values

#Prepare training and test dataset
prediction_size = 60
X = training_set
#train_size = int (round(len(X) * 0.7))
if web_traffic == True:
    train_size = 7000
if m2m == True:
    train_size = 80000
validation_start = train_size
validation_end = train_size + prediction_size
test_size = train_size + prediction_size

train = X[0:train_size]
#test = X[train_size:test_size]  
test = X[validation_start:validation_end]
predictions = []

import itertools
p=d=q=range(0,15)
pdq = list(itertools.product(p,d,q))

#print (pdq)

#Prepare ARIMA model
from statsmodels.tsa.arima_model import ARIMA

import warnings
warnings.filterwarnings('ignore')
temp_aic = 1000000000000
#temp_pdq = [(0, 2, 3)]

for param in pdq:
    try:
        model_arima = ARIMA(train,order=param)
        model_arima_fit = model_arima.fit()
        print(param,model_arima_fit.aic)
        if model_arima_fit.aic > 0:
            if model_arima_fit.aic < temp_aic:
                temp_aic = model_arima_fit.aic
                temp_pdq = param
    except:
        continue

print (temp_pdq, temp_aic)

#p,d,q  p = periods taken for autoregressive model
#d -> Integrated order, difference
# q periods in moving average model
#model_arima = ARIMA(train,order=(0,2,3))
model_arima = ARIMA(train,order=temp_pdq)
model_arima_fit = model_arima.fit(disp=0)
#print(model_arima_fit.aic)

predictions= model_arima_fit.forecast(steps=prediction_size)[0]

#plt.plot(test)
#plt.plot(predictions,color='red')

# Visualising the results
if web_traffic == True:
    plt.plot(test, color = 'red', label = 'Validation Traffic')
    plt.plot(predictions, color = 'blue', label = 'Predicted traffic')
    #plt.ylim (320,550)
    plt.title('Traffic Prediction (ARIMA)')
    plt.xlabel('Time Index (s)')
    plt.ylabel('Number of Packets')
    plt.legend(loc='best', prop={'size': 6})

elif m2m == True:
    init_val = 0;
    x_val = []
    for loop in range (prediction_size):
        x_val.append(init_val)
        init_val += 0.1
    plt.plot(x_val, test, color = 'green', label = 'Validaation Traffic')
    plt.plot(x_val, predictions, color = 'orange', label = 'Predicted traffic')
    plt.ylim (-50,7000)
    plt.title('Traffic Prediction (ARIMA)')
    plt.xlabel('Time Index (s)')
    plt.ylabel('Number of Packets')
    plt.legend(loc='best', prop={'size': 6})
    
plt.savefig('arima_valData_pkt.png',bbox_inches="tight", pad_inches=0, dpi=300)

plt.show()

from sklearn.metrics import mean_squared_error

from math import sqrt

mse = mean_squared_error(test, predictions)

rmse = sqrt(mse)

print('RMSE: %f' % rmse)


#print (predictions.shape)
X_test = np.reshape(test, (np.product(test.shape),))

df = pd.DataFrame(list(zip(X_test, predictions)),
              columns=['Test Traffic (packets)','Predicted Trafic (packets)'])

df.to_csv("arima_pkt.csv", index = None, header=True)

#print (df)